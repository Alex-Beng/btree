<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>B-Tree Reference</title>
  <link rel="stylesheet" type="text/css" href="minimal.css">
</head>

<body>
  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="277"><a href="../../../../index.htm"><img src=
      "../../../boost.png" alt="boost.png (6897 bytes)" align=
      "middle" width="300" height="86" border="0"></a></td>

      <td align="middle"><font size="7">B-Tree Library Reference</font></td>
    </tr>
  </table>

  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111" bgcolor=
  "#D7EEFF" width="100%">
    <tr>
      <td><a href="../../../index.htm">Boost Home</a>
      &nbsp;&nbsp; <a href="index.html">Library Home</a>
      &nbsp;&nbsp; <a href="reference.html">Reference</a>
      &nbsp;&nbsp; <a href="tutorial.html">Tutorial</a>
      &nbsp;&nbsp; <a href="faq.html">FAQ</a> &nbsp;&nbsp; <a href=
      "portability_guide.htm">Portability</a></td>
    </tr>
  </table>

  <h2>Header &lt;boost/btree/helpers.hpp&gt;</h2>

  <p>The components in this header are included by the other boost/btree 
  headers.</p>

  <h3>Synopsis</h3>

  <pre>namespace boost
{
namespace btree
{
  struct big_endian_traits;
  struct little_endian_traits;
  struct native_endian_traits;
  
  typedef big_endian_traits  default_traits;  // see rationale below
  
  namespace flags
  {
    enum bitmask
    {
      none          = 0,
  
      // bitmasks set by implemenation, ignored if passed in by user:
      unique        = 1,    // set or map
      key_only      = 2,    // set or multiset
   
      // open values (choose one):
      read_only   = 0x100,   // file must exist
      read_write  = 0x200,   // open existing file, otherwise create new file
      truncate    = 0x400,   // same as read_write except existing file truncated
  
      // bitmask options set by user; not present in header:
      preload        = 0x1000, // existing file read to preload O/S file cache
      cache_branches = 0x2000, // enable permanent cache of all branch pages touched;
                               // otherwise make branch pages available when use count
                               // becomes 0, just like leaf pages.
  
       // optimization hints; choose one. not present in header
       least_memory  = 0x10000,
       low_memory    = 0x20000,
       balanced      = 0,
       fast          = 0x30000,
       fastest       = 0x40000,
    };
  
    BOOST_BITMASK(bitmask);
  
    inline bitmask user_flags(bitmask m)             {return m & ~(unique|key_only); }
    inline bitmask permanent_flags(bitmask m)    {return m & (unique|key_only); }
  }  // namespace flags
}  // namespace btree
}  // namespace boost</pre>
  <h3>Traits</h3>
  <p>Traits provide the types for management objects on B-tree disk nodes. Nodes 
  are usually 4096 bytes in length for current hard disk hardware, and every 
  byte wasted in overhead causes a measurable reduction in speed as the tree 
  adds levels. That may favor unaligned traits, particularly if the user&#39;s key 
  and mapped types are also unaligned.</p>
  <p>On the other hand, aligned types are in theory more efficient and generate 
  less code.</p>
  <p>Actual timing tests on typical 2012 desktop hardware and operating systems, 
  show virtually no real-world speed differences between aligned and unaligned 
  traits, or native and non-native endian traits. Other factors, such as maximum 
  cache size, size of mapped data, portability, and so on, determine B-tree 
  performance.</p>
  <p>The <code>big_endian_traits</code> are chosen as the default because file 
  dumps are easier to read, files are portable, and none of the other traits 
  show any measurable effect on performance. </p>

  <p>&nbsp;</p>

  <h2>Header &lt;boost/btree/map.hpp&gt; synopsis</h2>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_map;

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_multimap;

struct big_endian_traits
{
  typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
  typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::big;
};

struct little_endian_traits
{
  typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::little;
};

struct native_endian_traits
{
  typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
#   ifdef BOOST_BIG_ENDIAN
        = endian::order::big;
#   else
        = endian::order::little;
#   endif
};

typedef big_endian_traits  default_traits;

} // namespace btree
} // namespace boost</pre>

  <h2>Class btree_map</h2>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
class btree_map
{
public:
  // types:
  typedef Key                                   key_type;
  typedef T                                     mapped_type;
  typedef typename Base::value_type             value_type;
  typedef Comp                                  key_compare;
  typedef typename Base::value_compare          value_compare; 
  typedef value_type&amp;                           reference;
  typedef const value_type&amp;                     const_reference;
  typedef boost::uint64_t                       size_type;
  typedef value_type*                           pointer;
  typedef const value_type*                     const_pointer;

  typedef iterator_type&lt;const value_type&gt;       iterator;
  typedef iterator                              const_iterator;

  typedef std::reverse_iterator&lt;iterator&gt;       reverse_iterator;
  typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
  typedef std::pair&lt;const_iterator, const_iterator&gt;
                                                const_iterator_range;

  typedef typename Traits::page_id_type         page_id_type;
  typedef typename Traits::page_size_type       page_size_type;
  typedef typename Traits::page_level_type      page_level_type;

  // construct/destroy:

  explicit btree_map(const Comp&amp; comp = Comp());

  explicit btree_map(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  template &lt;class InputIterator&gt;
  btree_map(InputIterator begin, InputIterator end,
    const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  ~btree_base();

  //  file operations:
  void open(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size);
  void flush();
  void close();

  // TODO: operator unspecified-bool-type, operator!
  
  // iterators:

  const_iterator          begin() const;
  const_iterator          end() const;
  const_iterator          last() const;
  const_reverse_iterator  rbegin() const;     
  const_reverse_iterator  rend() const;

  const_iterator          cbegin() const;
  const_iterator          cend() const;
  const_reverse_iterator  crbegin() const;    
  const_reverse_iterator  crend() const;

  // observers:
  key_compare             key_comp() const;
  value_compare           value_comp() const;
  const buffer_manager&amp;   manager() const;
  bool                    is_open() const;
  const filesystem::path&amp; file_path() const;
  bool                    read_only() const;
  const header_page&amp;      header() const;
  void                    dump_dot(std::ostream&amp; os) const; // Graphviz dot format

  // capacity:
  bool                    empty() const;
  size_type               size() const;
  std::size_t             page_size() const;
  std::size_t             max_cache_size() const;
  void                    max_cache_size(std::size_t m);

  // modifiers:
  std::pair&lt;const_iterator, bool&gt;
                          emplace(const Key&amp; key, const T&amp; mapped_value);
  std::pair&lt;const_iterator, bool&gt;
                          insert(const map_value&lt;Key, T&gt;&amp; value);

  template &lt;class InputIterator&gt;
  void                    insert(InputIterator begin, InputIterator end);

  iterator                update(iterator itr, const T&amp; mapped_value);
  const_iterator          erase(const_iterator position);
  size_type               erase(const key_type&amp; k);
  const_iterator          erase(const_iterator first, const_iterator last);
  void                    clear();

  // operations:
  const_iterator          find(const key_type&amp; k) const;
  size_type               count(const key_type&amp; k) const;

  const_iterator          lower_bound(const key_type&amp; k) const;
  const_iterator          upper_bound(const key_type&amp; k) const;

  const_iterator_range    equal_range(const key_type&amp; k) const;
};
} // namespace btree
} // namespace boost</pre>

  <h3>btree_map constructors and open</h3>
  <pre>explicit btree_map(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());

template &lt;class InputIterator&gt;
btree_map(InputIterator begin, InputIterator end,
  const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());</pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, signature, pg_sz, comp)</code>.</p>
    <p><i>Throws:</i> See <a href="#open">open</a>.</p>
  </blockquote>
  <pre>void <a name="open">open</a>(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size);</pre>
  <blockquote>
    <p><i>Throws:</i> <code>std::runtime_error</code> if the file exists and
    <code>flgs flags::truncate</code> is not set and:</p>
    <blockquote>
      <ul>
        <li>The file does not begin with a btree header, or</li>
        <li>Any of these attributes of the btree being opened are not equal to 
        the same attribute at time of file creation:<ul>
          <li><code>signature</code>,</li>
          <li>endianness,</li>
          <li>association arity [<i>Note:</i> sets are arity 1, maps are arity 2&nbsp;
          <i>-- end note</i>],</li>
          <li>association uniqueness [<i>Note:</i> sets and maps are unique, 
          multisets and multimaps are not unique&nbsp; <i>-- end note</i>],</li>
          <li><code>sizeof(key_type)</code>,</li>
          <li><code>sizeof(mapped_type)</code>.</li>
        </ul>
        </li>
      </ul>
    </blockquote>
  </blockquote>
  
  <hr>

  <p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->13 August 2013<!--webbot bot="Timestamp" endspan i-checksum="31355" --></p>

  <p>© Copyright Beman Dawes, 2013</p>

  <p>Distributed under the Boost Software License, Version 1.0. See
  <a href=
  "http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>

</html>