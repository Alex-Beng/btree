<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>B-Tree Reference</title>
  <link rel="stylesheet" type="text/css" href="minimal.css">
</head>

<body>
  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="277"><a href="../../../../index.htm"><img src=
      "../../../boost.png" alt="boost.png (6897 bytes)" align=
      "middle" width="300" height="86" border="0"></a></td>

      <td align="middle"><font size="7">B-Tree Library Reference</font></td>
    </tr>
  </table>

  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111" bgcolor=
  "#D7EEFF" width="100%">
    <tr>
      <td><a href="../../../index.htm">Boost Home</a>
      &nbsp;&nbsp; <a href="index.html">Library Home</a>
      &nbsp;&nbsp; <a href="reference.html">Reference</a>
      &nbsp;&nbsp; <a href="tutorial.html">Tutorial</a>
      &nbsp;&nbsp; <a href="faq.html">FAQ</a>
      &nbsp;&nbsp; <a href="portability_guide.htm">Portability</a></td>
    </tr>
  </table>

  <h2>Header &lt;boost/btree/helpers.hpp&gt;</h2>

  <p>The components in this header are included by the other boost/btree 
  headers. </p>

  <h3>Synopsis</h3>

  <pre>namespace boost { namespace btree
{
  //  Version numbers and default constants
  static const uint16_t major_version = 0;  // version identification
  static const uint16_t minor_version = 1;

  static const std::size_t default_node_size = 4096;  // determined by O/S page size

  //  <a href="#Traits">Traits</a>
  struct big_endian_traits;
  struct little_endian_traits;
  struct native_endian_traits;
  
  typedef big_endian_traits  default_traits;  // see rationale below
  
  //  <a href="#Flags">Flags</a>
  namespace flags
  {
    enum bitmask;

    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m);
    bitmask permanent_flags(bitmask m);
  }  // namespace flags
  
  //  <a href="#Constants">Constants</a>
  const uint32_t KB = 1024;
  const uint32_t MB = 1048576;  // 1024 * 1024
  const uint32_t GB = 1073741824;  // 1024 * 1024 * 1024
  
  //  <a href="#Hint-based-defaults">Hint based defaults</a>
  std::size_t     max_cache_default(flags::bitmask flgs, std::size_t file_size);
  flags::bitmask  cache_branches_default(flags::bitmask flgs);
  std::size_t     reserve_default(flags::bitmask flgs);
  
  //  <a href="#Function-object-less">Function object btree::less</a>
  struct less
  {
    template &lt;class T, class U&gt bool operator()(const T& t, const U& u) const
      { return t  &lt; u; }
  };
  
}}  // namespaces</pre>
  <h3><a name="Traits">Traits</a></h3>
  <p>Traits provide the types for management objects on B-tree disk nodes. Nodes 
  are usually 4096 bytes in length for current hard disk hardware, and every 
  byte wasted in overhead causes a measurable reduction in speed as the tree 
  adds levels. That may favor unaligned traits, particularly if the user&#39;s key 
  and mapped types are also unaligned.</p>
  <p>On the other hand, aligned types are in theory more efficient and generate 
  less code.</p>
  <p>Actual timing tests on typical 2012 desktop hardware and operating systems, 
  show virtually no real-world speed differences between aligned and unaligned 
  traits, or native and non-native endian traits. Other factors, such as maximum 
  cache size, size of mapped data, portability, and so on, determine B-tree 
  performance.</p>
  <p>The <code>big_endian_traits</code> are chosen as the default because file 
  dumps are easier to read, files are portable, and none of the other traits 
  show any measurable effect on performance.</p>

  <pre>namespace boost { namespace btree
{
 struct big_endian_traits
  {
    typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
    typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::big;
  };
  
  struct little_endian_traits
  {
    typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::little;
  };
    
  struct native_endian_traits
  {
    typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
  #   ifdef BOOST_BIG_ENDIAN
      = endian::order::big;
  #   else
      = endian::order::little;
  #   endif
  };

  typedef big_endian_traits  default_traits;  // see rationale above

}}  // namespaces </pre>

  <h3><a name="Flags">Flags</a></h3>

  <p>The <code>flags::bitmask</code> enum is a bitmask type [C++ 17.5.2.1.3 bitmask.types] 
  used to package disparate arguments to constructors and open functions into a 
  single value. </p>

  <pre>namespace boost { namespace btree
{
  namespace flags
  {
    enum bitmask
    {
      none          = 0,
  
      // bitmasks set by implemenation, ignored if passed in by user:
      unique        = 1,    // set or map
      key_only      = 2,    // set or multiset
   
      // open values (choose one):
      read_only   = 0x100,   // file must exist
      read_write  = 0x200,   // open existing file, otherwise create new file
      truncate    = 0x400,   // same as read_write except existing file truncated
  
      // bitmask options set by user; not present in header:
      preload        = 0x1000, // existing file read to preload O/S file cache
      cache_branches = 0x2000, // enable permanent cache of all branch nodes touched;
                               // otherwise make branch node available when use count
                               // becomes 0, just like leaf nodes.
  
      // optimization hints; choose one. not present in header
      least_memory  = 0x10000,
      low_memory    = 0x20000,
      balanced      = 0,
      fast          = 0x30000,
      fastest       = 0x40000,
    };
  
    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m)         {return m & ~(unique|key_only);}
    bitmask permanent_flags(bitmask m)    {return m & (unique|key_only);}
  }  // namespace flags  
}}  // namespaces</pre>

  <h3><a name="Constants">Constants</a></h3>

  <p>These constants are handy multipliers for specifying the large values 
  sometimes needed for size related function arguments. </p>

  <h3><a name="Hint-based-defaults">Hint based defaults</a></h3>

  <p>Internally, the optimization hint flags are translated into default values 
  by these functions. These values are unspecified to allow implementations to 
  make refinements as experience develops and hardware evolves. The functions 
  are exposed so that users can monitor the defaults if desired.</p>

  <h3><a name="Function-object-less">Function object <code>btree::less</code></a></h3>

  <p>Provides heterogeneous comparisons as required to implement indexes and 
  other indirect references. Also generally useful; see N3657, N3421. 
  Heterogeneous comparisons will be provided in the C++14 standard library, but 
  until then <code>btree::less</code> provides the functionality.</p>
  <p>Note: Allowing <code>less::operator()</code> to accept arguments of two 
  different types does not eliminate the requirement that objects of the two 
  types be themselves <code>&lt;</code> comparable. For example, type <code>fat</code> 
  in <a href="../test/btree_unit_test.cpp">test/btree_unit_test.cpp</a> 
  supplies, as required, two non-member <code>operator&lt;</code> functions so that 
  a <code>fat</code> object to be <code>&lt;</code> compared to an <code>int</code> 
  and an <code>int</code> can be compared to a <code>fat</code> object. </p>

  <h2>B-tree associative containers</h2>

  <p>Associative containers provide fast retrieval of data based on keys. The 
  library provides four basic kinds of associative containers: <code>btree_set</code>,
  <code>btree_multiset</code>, <code>btree_map</code> and <code>btree_multimap</code>.
  </p>
  <p dir="ltr">Each associative container is parameterized on <code>Key</code> 
  and an ordering relation <code>Compare</code> that induces a strict weak 
  ordering on elements of <code>Key</code>. In addition, <code>btree_map</code> 
  and <code>btree_multimap</code> associate an arbitrary mapped type <code>T</code> 
  with the <code>Key</code>. The object of type <code>Compare</code> is called 
  the comparison object of a container. </p>
  <p>The phrase “equivalence of keys” means the equivalence relation imposed by 
  the comparison and <i>not</i> the <code>operator==</code> on keys. That is, 
  two keys <code>k1</code> and <code>k2</code> are considered to be equivalent 
  if for the comparison object <code>comp</code>, <code>comp(k1, k2) == false &amp;&amp; 
  comp(k2, k1) == false</code>. For any two keys<code> k1</code> and <code>k2</code> 
  in the same container, calling <code>comp(k1, k2)</code> shall always return 
  the same value. </p>
  <p>An associative container supports unique keys if it may contain at most one 
  element for each key. Otherwise, it supports equivalent keys. The btree_set 
  and btree_map classes support unique keys; the btree_multiset and 
  btree_multimap classes support equivalent keys. For btree_multiset and 
  btree_multimap, insert, emplace, and erase preserve the relative ordering of 
  equivalent elements. </p>
  <p>For btree_set and btree_multiset the value type is the same as the key 
  type. For btree_map and btree_multimap it is equal to std::pair&lt;const Key, T&gt;.
  </p>
  <p><code>iterator</code> of an associative container is of the bidirectional 
  iterator category. For associative containers where the value type is the same 
  as the key type, both iterator and const_iterator are constant iterators. It 
  is unspecified whether or not iterator and const_iterator are the same type. [ 
  Note: iterator and const_- iterator have identical semantics in this case, and 
  iterator is convertible to const_iterator. Users can avoid violating the One 
  Definition Rule by always using const_iterator in their function parameter 
  lists. —end note ] </p>

  <h2>Sets</h2>

  <h3>Header &lt;boost/btree/set.hpp&gt; synopsis</h3>

  <pre>namespace boost { namespace btree
{
  template &lt;class Key,    // requires memcpyable type without pointers or references
            class Traits = default_traits,
            class Compare = btree::less&gt;
  class btree_set
  {
  public:
    // types:
    typedef Key                     key_type;
    typedef Key                     value_type;
    typedef Traits                  traits_type;
    typedef Compare                 key_compare;
    typedef Compare                 value_compare;
    typedef const value_type&amp;       reference;
    typedef const value_type&amp;       const_reference;
    typedef <i>implementation-defined</i>  iterator;
    typedef <i>implementation-defined</i>  const_iterator;
    typedef implementation-defined  size_type;
    typedef implementation-defined  difference_type;
    typedef const value_type*       pointer;
    typedef const value_type*       const_pointer;
    typedef std::reverse_iterator&lt;iterator&gt;
                                    reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt;
                                    const_reverse_iterator;
    // construct/destroy:
    explicit btree_set();

    explicit btree_set(const boost::filesystem::path&amp; pth,
      flags::bitmask flgs = flags::read_only,
      uint64_t sig = -1,
      const Compare&amp; comp = Compare(),
      std::size_t node_sz = default_node_size); 

    template &lt;class InputIterator&gt;
    btree_set(InputIterator begin, InputIterator end,
      const boost::filesystem::path&amp; pth,
      flags::bitmask flgs = flags::read_only,
      uint64_t sig = -1,
      const Compare&amp; comp = Compare(),
      std::size_t node_sz = default_node_size); 

   ~btree_set();

    //  file operations
    void open(const boost::filesystem::path&amp; pth,
      flags::bitmask flgs = flags::read_only,
      uint64_t sig = -1,
      const Compare&amp; comp = Compare(),
      std::size_t node_sz = default_node_size); 
    void                    flush();
    void                    close();

    // iterators
    const_iterator          begin() const;
    const_iterator          end() const;
    const_iterator          last() const;
    const_reverse_iterator  rbegin() const;     
    const_reverse_iterator  rend() const;

    const_iterator          cbegin() const;
    const_iterator          cend() const;
    const_reverse_iterator  crbegin() const;     
    const_reverse_iterator  crend() const;

    // observers
    bool                    is_open() const;
    const filesystem::path&amp; path() const;
    flags::bitmask          flags() const;

    // TODO: why are these two exposed? See main TODO list
    const buffer_manager&amp;   manager() const;
    const header_page&amp;      header() const;

    // capacity
    bool                    empty() const;
    size_type               size() const;
    size_type               max_size() const;
                           
    // tuning             
    std::size_t             node_size() const;
    std::size_t             max_cache_size() const;
    void                    max_cache_size(std::size_t m);  // -1 indicates unlimited
    void                    max_cache_megabytes(std::size_t mb);

    // modifiers    
    std::pair&lt;const_iterator, bool&gt;
      emplace(const value_type&amp; value);  // special case not requiring c++11x support

    std::pair&lt;const_iterator, bool&gt;
      insert(const value_type&amp; value);

    template &lt;class InputIterator&gt;
      void insert(InputIterator begin, InputIterator end);

    const_iterator          erase(const_iterator position);
    size_type               erase(const key_type&amp; k);
    const_iterator          erase(const_iterator first, const_iterator last);
    void                    clear();
                          
    // observers         
    key_compare             key_comp() const;
    value_compare           value_comp() const;
    bool                    ok_to_pack() const;

    // operations
    //   objects of types K and Key are required to be key_comp() comparable
    template &lt;class K&gt;
    const_iterator          find(const K&amp; k) const;
    const_iterator          find(const Key&amp; k) const;

    template &lt;class K&gt;
    size_type               count(const K&amp; k) const;
    size_type               count(const Key&amp; k) const;

    template &lt;class K&gt;
    const_iterator          lower_bound(const K&amp; k) const;
    const_iterator          lower_bound(const Key&amp; k) const;

    template &lt;class K&gt;
    const_iterator          upper_bound(const K&amp; k) const;
    const_iterator          upper_bound(const Key&amp; k) const;

    template &lt;class K&gt;
    const_iterator_range    equal_range(const K&amp; k) const;
    const_iterator_range    equal_range(const Key&amp; k) const;
  };
}}  // namespaces</pre>

<h4><a name="btree_set-constructors-and-destructor"><code>btree_set</code> constructors and 
destructor</a> </h4>

  <pre>explicit btree_set();</pre>
  <blockquote>
    <p><i>Postconditions:</i> <code>is_open()</code> is <code>false</code>.</p>
  </blockquote>
  <pre>explicit btree_set(const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, sig, comp, node_sz)</code></p>
  </blockquote>
  <pre>template &lt;class InputIterator&gt;
btree_set(InputIterator begin, InputIterator end,
  const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, sig, comp, node_sz)</code></p>
  </blockquote>
  <pre>~btree_set();</pre>
  <blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <pre>try { close(); }
catch (...) {}</pre>
  </blockquote>
  </blockquote>
  <pre>void open(const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>false</code>.<p><i>Postconditions:</i><blockquote>
      <blockquote>
        <blockquote>
          <blockquote>
    
    <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
      <tr>
        <td align="center"><i><b>File <code>p</code> does not exist<br>
        or flgs &amp; flags::truncate</b></i></td>
        <td align="center"><i><b>File <code>p</code> exists</b></i></td>
      </tr>
      <tr>
        <td><code>path() == p</code></td>
        <td><code>path() == p</code></td>
      </tr>
      <tr>
        <td><code>is_open() == true</code></td>
        <td>
        <p dir="ltr"><code>is_open() == true</code></td>
      </tr>
      <tr>
        <td><code>key_comp() == comp</code></td>
        <td>
        <p dir="ltr"><code>key_comp(</code>) at file creation</td>
      </tr>
      <tr>
        <td><code>value_comp() == comp</code></td>
        <td>
        <p dir="ltr"><code>value_comp()</code> at file creation</td>
      </tr>
      <tr>
        <td><code>node_size() == node_sz</code></td>
        <td>
        <p dir="ltr"><code>node_size()</code> at file creation</td>
      </tr>
      <tr>
        <td><code>empty() == true</code></td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><code>size() == 0</code></td>
        <td>&nbsp;</td>
      </tr>
    </table>
          </blockquote>
        </blockquote>
      </blockquote>
    </blockquote>
    
    <p><i>Throws:</i> If the path <code>p</code> cannot be opened, or the type 
    or signature differ from when the file was originally created.</p>
  </blockquote>
  <pre>void  flush();</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Any data that has been modified is written to the 
    external file.</p>
  </blockquote>
  <pre>void  close();</pre>
  <blockquote>
    <p><i>Effects:</i> if <code>is_open()</code>, <code>flush()</code> and then 
    close the external file. Otherwise, no effect.</p>
    <p><i>Postconditions:</i> <code>is_open() == false</code></p>
  </blockquote>
  <pre>const_iterator  begin() const;
const_iterator  cbegin() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element in the 
    container.</p>
  </blockquote>
  <pre>const_iterator  end() const;
const_iterator  cend() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A past-the-end iterator that does not point to an element 
    in the container.</p>
  </blockquote>
  <pre>const_reverse_iterator  rbegin() const;
const_reverse_iterator  crbegin() const;  </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> <code>std::reverse_iterator(end())</code>.</p>
  </blockquote>
  <pre>const_reverse_iterator  rend() const;
const_reverse_iterator  crend() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> <code>std::reverse_iterator(begin())</code>.</p>
  </blockquote>
  <pre>bool  is_open() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>true</code> if the <code>open</code> function has 
    been called and did not throw and exception, and the <code>close</code> 
    function has not been subsequently called. Otherwise, <code>false</code>.</p>
  </blockquote>
  <pre>const filesystem::path&amp; path() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A copy of <code>pth</code> from the constructor or <code>
    open</code> function that opened the file.</p>
  </blockquote>
  <pre>flags::bitmask  flags() const;</pre>
  <blockquote>
    <p dir="ltr"><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p dir="ltr"><i>Returns:</i> The effective value of <code>flgs</code> from 
    the constructor or <code>open</code> function that opened the file.</p>
    <p dir="ltr"><i>Remarks:</i> The effective value is the actual value 
    adjusted to reflect possible presence of <code>unique</code> and <code>
    key_only</code> flags, and application of hints.</p>
  </blockquote>
  <pre>const buffer_manager&amp;  manager() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A reference to the <code>buffer_manager</code> object for 
    the container.</p>
  </blockquote>
  <pre>const header_page&amp;  header() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A reference to the <code>header_page</code> object for 
    the container.</p>
  </blockquote>
  <pre>bool  empty() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>!size()</code></p>
  </blockquote>
  <pre>size_type  size() const;</pre>
  <blockquote>
    <p><i>Returns:</i> The number of elements in the container.</p>
  </blockquote>
  <pre>size_type  max_size() const;</pre>
  <blockquote>
    <p dir="ltr"><i>Returns:</i> <code>-1</code>.</p>
    <p dir="ltr">[<i>Note:</i> This function is effectively useless, and is 
    provided only because the standard library provides a similar useless 
    function! <i>-- end note</i>]</p>
  </blockquote>
  <pre>std::size_t  node_size() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The value of the <code>node_sz</code> argument to the
    <code>open</code> function at the time of original file creation.</p>
  </blockquote>
  <pre>std::size_t  max_cache_size() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The value of the <code>max</code> argument to the most 
    recent call to the <code>max_cache_size</code> function.</p>
  </blockquote>
  <pre>void  max_cache_size(std::size_t max);  </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i>&nbsp; Informs the implementation of the maximum number of 
    nodes to be cached. <code>max</code> of <code>-1</code> indicates no limit.</p>
    <p>[<i>Note:</i> More nodes may be cached if required to maintain the 
    validity of outstanding iterators. <i>-- end note</i>]</p>
  </blockquote>
  <pre>void  max_cache_megabytes(std::size_t mb);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> <code>max_cache_size((mb*1048576)/node_size())</code><i>.</i></p>
  </blockquote>
  <pre>std::pair&lt;const_iterator, bool&gt;
  emplace(const value_type&amp; value);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts a value_type object t constructed with 
    std::forward&lt;Args&gt;(args)... if and only if there is no element in the 
    container with key equivalent to the key of t. The bool component of the 
    returned pair is true if and only if the insertion takes place, and the 
    iterator component of the pair points to the element with key equivalent to 
    the key of t.</p>
    <p><i>Returns:</i> </p>
  </blockquote>
  <pre>std::pair&lt;const_iterator, bool&gt;
  insert(const value_type&amp; value);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts <code>value</code> if and only if there is no 
    element in the container with key equivalent to the key of <code>value</code>. 
    The <code>bool</code> component of the returned pair is <code>true</code> if 
    and only if the insertion takes place, and the iterator component of the 
    pair points to the element with key equivalent to the key of <code>value</code>.</p>
    <p><i>Returns:</i> The pair described in <i>Effects</i>.</p>
  </blockquote>
  <pre>template &lt;class InputIterator&gt;
  void insert(InputIterator begin, InputIterator end);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>value_type</code> is constructible from <code>
    *begin</code>. <code>begin</code> and <code>end</code> are not iterators 
    into <code>*this</code>. <code>is_open()</code> is <code>true</code>. </p>
    <p><i>Effects:</i> Inserts each element from the range <code>[begin,end)</code> 
    if and only if there is no element with key equivalent to the key of that 
    element.</p>
  </blockquote>
  <pre>const_iterator  erase(const_iterator position);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> Erases the element pointed to by <code>position</code>. 
    Returns an iterator pointing to the element immediately following <code>
    position</code> prior to the element being erased. If no such element 
    exists, returns <code>end()</code>.</p>
  </blockquote>
  <pre>size_type  erase(const key_type&amp; k);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> If it exists, erases the element in the container with 
    key equivalent to <code>k</code>.</p>
    <p><i>Returns:</i>&nbsp; The number of elements erased.</p>
  </blockquote>
  <pre>const_iterator  erase(const_iterator begin, const_iterator end);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Erases all the elements in the range <code>[begin,end)</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the element following the last 
    element erased, or <code>end()</code> if there is no element following the 
    last erased element. [<i>Note:</i> this iterator is equivalent to end, but 
    is a valid iterator whereas end has been invalidated by the erase. <i>--end 
    note</i>]</p>
  </blockquote>
  <pre>void  clear();</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Postconditions:</i> <code>empty()</code> is <code>true</code>.</p>
  </blockquote>
  <pre>key_compare  key_comp() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The comparison object from the constructor or <code>open</code> 
    function.</p>
  </blockquote>
  <pre>value_compare  value_comp() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A <code>value_compare</code> object constructed from the 
    comparison object from the constructor or <code>open</code> function.</p>
  </blockquote>
  <pre>bool  ok_to_pack() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>true</code> if all prior <code>insert</code> and
    <code>emplace</code> calls have been applied at <code>end()</code>, and 
    there have been no <code>erase</code> calls.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator  find(const K&amp; k) const;
const_iterator  find(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the element with the key 
    equivalent to <code>k</code>, or <code>end()</code> if such an element is 
    not found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
size_type  count(const K&amp; k) const;
size_type  count(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The number of elements with key equivalent to <code>k</code>.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator  lower_bound(const K&amp; k) const;
const_iterator  lower_bound(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element with key not 
    less than <code>k</code>, or <code>end()</code> if such an element is not 
    found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator  upper_bound(const K&amp; k) const;
const_iterator  upper_bound(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element with key 
    greater than <code>k</code>, or <code>end()</code> if such an element is not 
    found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator_range  equal_range(const K&amp; k) const;
const_iterator_range  equal_range(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> Equivalent to <code>std::make_pair(lower_bound(k), 
    upper_bound(k)</code>).</p>
  </blockquote>
  <h3>Header &lt;boost/btree/multiset.hpp&gt; synopsis</h3>

  <h2>Maps</h2>

  <h3>Header &lt;boost/btree/map.hpp&gt; synopsis</h3>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_map;

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_multimap;

struct big_endian_traits
{
  typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
  typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::big;
};

struct little_endian_traits
{
  typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::little;
};

struct native_endian_traits
{
  typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
#   ifdef BOOST_BIG_ENDIAN
        = endian::order::big;
#   else
        = endian::order::little;
#   endif
};

typedef big_endian_traits  default_traits;

} // namespace btree
} // namespace boost</pre>

  <h2>Class btree_map</h2>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
class btree_map
{
public:
  // types:
  typedef Key                                   key_type;
  typedef T                                     mapped_type;
  typedef typename Base::value_type             value_type;
  typedef Comp                                  key_compare;
  typedef typename Base::value_compare          value_compare; 
  typedef value_type&amp;                           reference;
  typedef const value_type&amp;                     const_reference;
  typedef boost::uint64_t                       size_type;
  typedef value_type*                           pointer;
  typedef const value_type*                     const_pointer;

  typedef iterator_type&lt;const value_type&gt;       iterator;
  typedef iterator                              const_iterator;

  typedef std::reverse_iterator&lt;iterator&gt;       reverse_iterator;
  typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
  typedef std::pair&lt;const_iterator, const_iterator&gt;
                                                const_iterator_range;

  typedef typename Traits::page_id_type         page_id_type;
  typedef typename Traits::page_size_type       page_size_type;
  typedef typename Traits::page_level_type      page_level_type;

  // construct/destroy:

  explicit btree_map(const Comp&amp; comp = Comp());

  explicit btree_map(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  template &lt;class InputIterator&gt;
  btree_map(InputIterator begin, InputIterator end,
    const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  ~btree_base();

  //  file operations:
  void open(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size);
  void flush();
  void close();

  // TODO: operator unspecified-bool-type, operator!
  
  // iterators:

  const_iterator          begin() const;
  const_iterator          end() const;
  const_iterator          last() const;
  const_reverse_iterator  rbegin() const;     
  const_reverse_iterator  rend() const;

  const_iterator          cbegin() const;
  const_iterator          cend() const;
  const_reverse_iterator  crbegin() const;    
  const_reverse_iterator  crend() const;

  // observers:
  key_compare             key_comp() const;
  value_compare           value_comp() const;
  const buffer_manager&amp;   manager() const;
  bool                    is_open() const;
  const filesystem::path&amp; file_path() const;
  bool                    read_only() const;
  const header_page&amp;      header() const;
  void                    dump_dot(std::ostream&amp; os) const; // Graphviz dot format

  // capacity:
  bool                    empty() const;
  size_type               size() const;
  std::size_t             page_size() const;
  std::size_t             max_cache_size() const;
  void                    max_cache_size(std::size_t m);

  // modifiers:
  std::pair&lt;const_iterator, bool&gt;
                          emplace(const Key&amp; key, const T&amp; mapped_value);
  std::pair&lt;const_iterator, bool&gt;
                          insert(const map_value&lt;Key, T&gt;&amp; value);

  template &lt;class InputIterator&gt;
  void                    insert(InputIterator begin, InputIterator end);

  iterator                update(iterator itr, const T&amp; mapped_value);
  const_iterator          erase(const_iterator position);
  size_type               erase(const key_type&amp; k);
  const_iterator          erase(const_iterator first, const_iterator last);
  void                    clear();

  // operations:
  const_iterator          find(const key_type&amp; k) const;
  size_type               count(const key_type&amp; k) const;

  const_iterator          lower_bound(const key_type&amp; k) const;
  const_iterator          upper_bound(const key_type&amp; k) const;

  const_iterator_range    equal_range(const key_type&amp; k) const;
};
} // namespace btree
} // namespace boost</pre>

  <h3>btree_map constructors and open</h3>
  <pre>explicit btree_map(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());

template &lt;class InputIterator&gt;
btree_map(InputIterator begin, InputIterator end,
  const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());</pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, signature, pg_sz, comp)</code>.</p>
    <p><i>Throws:</i> See <a href="#open">open</a>.</p>
  </blockquote>
  <pre>void <a name="open">open</a>(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size);</pre>
  <blockquote>
    <p><i>Throws:</i> <code>std::runtime_error</code> if the file exists and
    <code>flgs flags::truncate</code> is not set and:</p>
    <blockquote>
      <ul>
        <li>The file does not begin with a btree header, or</li>
        <li>Any of these attributes of the btree being opened are not equal to 
        the same attribute at time of file creation:<ul>
          <li><code>signature</code>,</li>
          <li>endianness,</li>
          <li>association arity [<i>Note:</i> sets are arity 1, maps are arity 2&nbsp;
          <i>-- end note</i>],</li>
          <li>association uniqueness [<i>Note:</i> sets and maps are unique, 
          multisets and multimaps are not unique&nbsp; <i>-- end note</i>],</li>
          <li><code>sizeof(key_type)</code>,</li>
          <li><code>sizeof(mapped_type)</code>.</li>
        </ul>
        </li>
      </ul>
    </blockquote>
  </blockquote>
  
  <hr>

  <p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->15 August 2013<!--webbot bot="Timestamp" endspan i-checksum="31359" --></p>

  <p>© Copyright Beman Dawes, 2013</p>

  <p>Distributed under the Boost Software License, Version 1.0. See
  <a href=
  "http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>

</html>