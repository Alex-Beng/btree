<html>
<head>
  <meta name="generator" content=
  "Microsoft FrontPage 5.0">
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <meta name="ProgId" content="FrontPage.Editor.Document">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>B-Tree Home</title>
  <link rel="stylesheet" type="text/css" href="minimal.css">
</head>

<body>
  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="277"><a href="../../../../index.htm"><img src=
      "../../../boost.png" alt="boost.png (6897 bytes)" align=
      "middle" width="300" height="86" border="0"></a></td>

      <td align="middle"><font size="7">B-Tree Library<br>
      Tutorial</font></td>
    </tr>
  </table>

  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111" bgcolor=
  "#D7EEFF" width="100%">
    <tr>
      <td><a href="../../../index.htm">Boost Home</a>
      &nbsp;&nbsp; <a href="index.html">Library Home</a>
      &nbsp;&nbsp; <a href="reference.html">Reference</a>
      &nbsp;&nbsp; <a href="tutorial.html">Tutorial</a>
      &nbsp;&nbsp; <a href="faq.html">FAQ</a> &nbsp;&nbsp; <a href=
      "data_portability.html">Data Portability</a></td>
    </tr>
  </table>

   <h2>A simple set</h2>
   
   <p>The library provides associative containers that are resident on some form 
   of direct access external memory, such as a hard-disk, solid-state disk, or 
   USB memory-stick.&nbsp; Here is an example, <a href="../example/set1.cpp">set1.cpp</a>:</p>
   
  <blockquote>
    <pre>#include &lt;boost/btree/btree_set.hpp&gt;
#include &lt;iostream&gt;
using std::cout;
using namespace boost::btree;

int main()
{
  <span style="background-color: #FFFFAC">btree_set</span><span style="background-color: #FFFFAC">&lt;int&gt; </span><span style="background-color: #FFFFAC">set(&quot;set.btr</span><span style="background-color: #FFFFAC">&quot;, </span><span style="background-color: #FFFFAC">flags::truncate</span><span style="background-color: #FFFFAC">);</span>

  set.insert(5);
  set.insert(3);
  set.insert(1);

  for (btree_set&lt;int&gt;::iterator it = set.begin();
    it != set.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;

  cout &lt;&lt; &quot;lower_bound(3) is &quot; &lt;&lt; *set.lower_bound(3) &lt;&lt; &#39;\n&#39;;
  cout &lt;&lt; &quot;upper_bound(3) is &quot; &lt;&lt; *set.upper_bound(3) &lt;&lt; &#39;\n&#39;;

  return 0;
}</pre>
  </blockquote>

   <p>This should be familiar to users of the C++ standard library 
   associative container <code>std::set</code>. The only real difference, other 
   than names, is the high-lighted constructor call. Because the 
   container is disk-resident, an argument supplies a path for the file to be 
   created. A second argument supplies <a href="reference.html#Flags">flags</a> 
   that specify details for opening the file. </p>
   
   <p>Build and test set1.cpp like this (Windows):</p>
   
  <blockquote>
    <pre>&gt;cd boost-root/libs/btree/example   <b><i>Works for both Windows and POSIX</i></b>
&gt;b2 set1 install
<i>... build output elided ...</i>
&gt;bin\set1         <i><b>                  On POSIX: bin/set1</b></i>
1
3
5
lower_bound(3) is 3
upper_bound(3) is 5</pre>
  </blockquote>
  
  <p>Go ahead and try this yourself! Once you have built and tested set1.cpp as 
  is, try experimenting with some of the other functions already familiar to you 
  from <code>std::set</code>. Did they work as you expected? Hopefully you 
  answer was &quot;yes&quot;!</p>
  
  <p>What is the point of using a <code>btree_set</code> instead of a <code>
  std::set</code>? Let&#39;s look at another example...</p>
  
  <h2>Reading from a B-tree file</h2>
  
  <p>Here is the sample code for set_read_file.cpp, showing edits from set1.cpp:</p>
  
  <blockquote>
    <pre>#include &lt;boost/btree/btree_set.hpp&gt;
#include &lt;iostream&gt;
using std::cout;
using namespace boost::btree;

int main()
{
  <del>btree_set&lt;int&gt; set(&quot;set1.btr&quot;, flags::truncate);</del>
  <ins>btree_set&lt;int&gt; set(&quot;set1.btr&quot;);</ins>

  <del>set.insert(5);</del>
  <del>set.insert(3);</del>
  <del>set.insert(1);</del>

  for (btree_set&lt;int&gt;::iterator it = set.begin();
    it != set.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;

  cout &lt;&lt; &quot;lower_bound(3) is &quot; &lt;&lt; *set.lower_bound(3) &lt;&lt; &#39;\n&#39;;
  cout &lt;&lt; &quot;upper_bound(3) is &quot; &lt;&lt; *set.upper_bound(3) &lt;&lt; &#39;\n&#39;;

  return 0;
}
</pre>
  
  </blockquote>
  
  <p>Since the &quot;set1.btr&quot; file already exists, we let the constructor flags 
  default to <code>flags::read_only</code> and don&#39;t redo the inserts.</p>
  <p>The first time this program ran, it crashed with one of those totally 
  unhelpful Windows error messages. After slapping my forehead, I changed to code to use 
  an exception reporting wrapper:</p>
  <blockquote>
    <pre>#include &lt;boost/btree/btree_set.hpp&gt;
#include &lt;iostream&gt;
<ins>#include &lt;boost/detail/lightweight_main.hpp&gt;</ins> 

using std::cout;
using namespace boost::btree;

<del>int main()</del>
<ins>int cpp_main(int, char *[])</ins>
{
  btree_set&lt;int&gt; set(&quot;set1.btr&quot;);

  for (btree_set&lt;int&gt;::iterator it = set.begin();
    it != set.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;

  cout &lt;&lt; &quot;lower_bound(3) is &quot; &lt;&lt; *set.lower_bound(3) &lt;&lt; &#39;\n&#39;;
  cout &lt;&lt; &quot;upper_bound(3) is &quot; &lt;&lt; *set.upper_bound(3) &lt;&lt; &#39;\n&#39;;

  return 0;
}
</pre>
  </blockquote>
  <p>That compiled and ran, with the exception reporting wrapper</p>
  <blockquote>
  <pre>ERROR  ERROR  ERROR  ERROR  ERROR  ERROR  ERROR  ERROR  ERROR  ERROR  ERROR

****************************** std::exception *****************************
binary_file::open: The system cannot find the file specified: &quot;set1.btr&quot;
***************************************************************************
</pre>
  </blockquote>
  <p>That illustrates an important point: because B-trees are disk resident, 
  errors are a commonplace, so your code should expect exceptions to be thrown.</p>
  
  <p>After fixing the snafu that put set1.btr in a different directory, set_read_file.cpp 
  ran fine:</p>
  
  <blockquote>
    <pre>1
3
5
lower_bound(3) is 3
upper_bound(3) is 5</pre>
  </blockquote>
  <p>That brings us back to the original point; <b>B-tree are disk resident</b>, 
  and that makes them very different animals from standard library associative 
  containers.</p>
  
  <p>What about the additional template parameters, constructor arguments, 
  and member functions that are not present in <code>std::set</code>? You may have spotted 
  these if you looked at the
  <a href="reference.html">referenced documentation</a>? Don&#39;t worry about them 
  for now; the defaults will get you started, and most of the unfamiliar 
  parameters, arguments, and functions are used only when 
  tuning for ultimate performance.</p>
  
  <p>What you probably do want to learn about right away is how to cope with the 
  very stringent requirements the library places on template parameter <code>Key</code> (and 
  <code>T</code>, for maps), since these requirements will cause endless problems if you 
  don&#39;t understand them. Read on...</p>
  
  <h2>String example</h2>
  
  <p>An obvious transformation of set1.cpp to handle strings instead of ints 
  looks like example set2_1st_try.cpp:</p>
  
  <blockquote>
    <pre>#include &lt;boost/btree/btree_set.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using std::cout;
using namespace boost::btree;

int main()
{
  typedef btree_set&lt;std::string&gt; set_type;
  set_type set(&quot;set2.btr&quot;, flags::truncate);

  set.insert(&quot;eat&quot;);
  set.insert(&quot;drink&quot;);
  set.insert(&quot;be merry&quot;);

  for (set_type::iterator it = set.begin(); it != set.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;

  return 0;
}
</pre>
  </blockquote>
  
  <p>But this code will not compile! The error message from Visual C++ 2012 
  looks like this:</p>
  
  <blockquote>
  
  <pre>..\..\..\boost/btree/btree_set.hpp(120) : error C2338: btree Key must not be std::string
set2_1st_try.cpp(16) : see reference to class template instantiation &#39;boost::btree
::btree_set&lt;Key&gt;&#39; being compiled
with
[
Key=std::string
]
...</pre>
  </blockquote>
  <h2>Corrected string example</h2>
  
  <blockquote>
    <pre><del>#include &lt;boost/btree/btree_set.hpp&gt;</del>
<ins>#include &lt;boost/btree/btree_set_index.hpp&gt;</ins>
#include &lt;string&gt;
#include &lt;iostream&gt;
using std::cout;
using namespace boost::btree;

int main()
{
  <del>typedef btree_set&lt;std::string&gt; set_type;</del>
  <ins>typedef btree_set_index&lt;boost::string_view&gt; set_type;</ins>
  <del>set_type set(&quot;set2.btr&quot;, flags::truncate);</del>
  <ins>set_type set(&quot;set2.ndx&quot;, &quot;set2.dat&quot;, flags::truncate);</ins>

  set.insert(&quot;eat&quot;);
  set.insert(&quot;drink&quot;);
  set.insert(&quot;be merry&quot;);

  for (set_type::iterator it = set.begin(); it != set.end(); ++it)
    cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;

  return 0;
}
</pre>
  </blockquote>
  
  
  <p>Finally, let&#39;s look at the output of running set2:</p>
  
  <blockquote>
    <pre>be merry
drink
eat
</pre>
  </blockquote>
  <p>No surprises there! Let&#39;s move on to maps...</p>
  <h2 dir="ltr">A simple map</h2>
  <p>...</p>
  <p>...</p>
  <hr>

  <p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->20 August 2013<!--webbot bot="Timestamp" endspan i-checksum="31350" --></p>

  <p>Â© Copyright Beman Dawes, 2013</p>

  <p>Distributed under the Boost Software License, Version 1.0. See
  <a href=
  "http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>
</html>