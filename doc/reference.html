<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>B-Tree Reference</title>
  <link rel="stylesheet" type="text/css" href="minimal.css">
</head>

<body>
  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="277"><a href="../../../../index.htm"><img src=
      "../../../boost.png" alt="boost.png (6897 bytes)" align=
      "middle" width="300" height="86" border="0"></a></td>

      <td align="middle"><font size="7">B-Tree Library Reference</font></td>
    </tr>
  </table>

  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111" bgcolor=
  "#D7EEFF" width="100%">
    <tr>
      <td><a href="../../../index.htm">Boost Home</a>
      &nbsp;&nbsp; <a href="index.html">Library Home</a>
      &nbsp;&nbsp; <a href="reference.html">Reference</a>
      &nbsp;&nbsp; <a href="tutorial.html">Tutorial</a>
      &nbsp;&nbsp; <a href="faq.html">FAQ</a> &nbsp;&nbsp; <a href=
      "portability_guide.htm">Portability</a></td>
    </tr>
  </table>

  <h2>Header &lt;boost/btree/helpers.hpp&gt;</h2>

  <p>The components in this header are included by the other boost/btree 
  headers.</p>

  <h3>Synopsis</h3>

  <pre>namespace boost { namespace btree
{
  //  Version numbers and default constants
  static const uint16_t major_version = 0;  // version identification
  static const uint16_t minor_version = 1;

  static const std::size_t default_node_size = 4096;  // determined by O/S page size

  //  <a href="#Traits">Traits</a>
  struct big_endian_traits;
  struct little_endian_traits;
  struct native_endian_traits;
  
  typedef big_endian_traits  default_traits;  // see rationale below
  
  //  <a href="#Flags">Flags</a>
  namespace flags
  {
    enum bitmask;

    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m);
    bitmask permanent_flags(bitmask m);
  }  // namespace flags
  
  //  <a href="#Constants">Constants</a>
  const uint32_t KB = 1024;
  const uint32_t MB = 1048576;  // 1024 * 1024
  const uint32_t GB = 1073741824;  // 1024 * 1024 * 1024
  
  //  <a href="#Hint-based-defaults">Hint based defaults</a>
  std::size_t     max_cache_default(flags::bitmask flgs, std::size_t file_size);
  flags::bitmask  cache_branches_default(flags::bitmask flgs);
  std::size_t     reserve_default(flags::bitmask flgs);
  
  //  <a href="#Function-object-less">Function object btree::less</a>
  struct less
  {
    template &lt;class T, class U&gt bool operator()(const T& t, const U& u) const
      { return t  &lt; u; }
  };
  
}}  // namespaces</pre>
  <h3><a name="Traits">Traits</a></h3>
  <p>Traits provide the types for management objects on B-tree disk nodes. Nodes 
  are usually 4096 bytes in length for current hard disk hardware, and every 
  byte wasted in overhead causes a measurable reduction in speed as the tree 
  adds levels. That may favor unaligned traits, particularly if the user&#39;s key 
  and mapped types are also unaligned.</p>
  <p>On the other hand, aligned types are in theory more efficient and generate 
  less code.</p>
  <p>Actual timing tests on typical 2012 desktop hardware and operating systems, 
  show virtually no real-world speed differences between aligned and unaligned 
  traits, or native and non-native endian traits. Other factors, such as maximum 
  cache size, size of mapped data, portability, and so on, determine B-tree 
  performance.</p>
  <p>The <code>big_endian_traits</code> are chosen as the default because file 
  dumps are easier to read, files are portable, and none of the other traits 
  show any measurable effect on performance.</p>

  <pre>namespace boost { namespace btree
{
 struct big_endian_traits
  {
    typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
    typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::big;
  };
  
  struct little_endian_traits
  {
    typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::little;
  };
    
  struct native_endian_traits
  {
    typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
  #   ifdef BOOST_BIG_ENDIAN
      = endian::order::big;
  #   else
      = endian::order::little;
  #   endif
  };

  typedef big_endian_traits  default_traits;  // see rationale above

}}  // namespaces </pre>

  <h3><a name="Flags">Flags</a></h3>

  <p>The <code>flags::bitmask</code> enum is a bitmask type [C++ 17.5.2.1.3 bitmask.types] 
  used to package disparate arguments to constructors and open functions into a 
  single value. </p>

  <pre>namespace boost { namespace btree
{
  namespace flags
  {
    enum bitmask
    {
      none          = 0,
  
      // bitmasks set by implemenation, ignored if passed in by user:
      unique        = 1,    // set or map
      key_only      = 2,    // set or multiset
   
      // open values (choose one):
      read_only   = 0x100,   // file must exist
      read_write  = 0x200,   // open existing file, otherwise create new file
      truncate    = 0x400,   // same as read_write except existing file truncated
  
      // bitmask options set by user; not present in header:
      preload        = 0x1000, // existing file read to preload O/S file cache
      cache_branches = 0x2000, // enable permanent cache of all branch nodes touched;
                               // otherwise make branch node available when use count
                               // becomes 0, just like leaf nodes.
  
      // optimization hints; choose one. not present in header
      least_memory  = 0x10000,
      low_memory    = 0x20000,
      balanced      = 0,
      fast          = 0x30000,
      fastest       = 0x40000,
    };
  
    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m)         {return m & ~(unique|key_only);}
    bitmask permanent_flags(bitmask m)    {return m & (unique|key_only);}
  }  // namespace flags  
}}  // namespaces</pre>

  <h3><a name="Constants">Constants</a></h3>

  <p>These constants are handy multipliers for specifying the large values 
  sometimes needed for size related function arguments. </p>

  <h3><a name="Hint-based-defaults">Hint based defaults</a></h3>

  <p>Internally, the optimization hint flags are translated into default values 
  by these functions. These values are unspecified to allow implementations to 
  make refinements as experience develops and hardware evolves. The functions 
  are exposed so that users can monitor the defaults if desired.</p>

  <h3><a name="Function-object-less">Function object <code>btree::less</code></a></h3>

  <p>Provides heterogeneous comparisons as required to implement indexes and 
  other indirect references. Also generally useful; see N3657, N3421. 
  Heterogeneous comparisons will be provided in the C++14 standard library, but 
  until then <code>btree::less</code> provides the functionality.</p>
  <p>Note: Allowing <code>less::operator()</code> to accept arguments of two 
  different types does not eliminate the requirement that objects of the two 
  types be themselves <code>&lt;</code> comparable. For example, type <code>fat</code> 
  in <a href="../test/btree_unit_test.cpp">test/btree_unit_test.cpp</a> 
  supplies, as required, two non-member <code>operator&lt;</code> functions so that 
  a <code>fat</code> object to be <code>&lt;</code> compared to an <code>int</code> 
  and an <code>int</code> can be compared to a <code>fat</code> object. </p>

  <h2>Header &lt;boost/btree/map.hpp&gt; synopsis</h2>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_map;

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
  class btree_multimap;

struct big_endian_traits
{
  typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
  typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::big;
};

struct little_endian_traits
{
  typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
    = endian::order::little;
};

struct native_endian_traits
{
  typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
  typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
  typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
  static const BOOST_SCOPED_ENUM(endian::order) header_endianness
#   ifdef BOOST_BIG_ENDIAN
        = endian::order::big;
#   else
        = endian::order::little;
#   endif
};

typedef big_endian_traits  default_traits;

} // namespace btree
} // namespace boost</pre>

  <h2>Class btree_map</h2>
    <pre>namespace boost { namespace btree {

template &lt;class Key, class T, class Traits = default_traits,
          class Comp = btree::less&lt;Key&gt; &gt;
class btree_map
{
public:
  // types:
  typedef Key                                   key_type;
  typedef T                                     mapped_type;
  typedef typename Base::value_type             value_type;
  typedef Comp                                  key_compare;
  typedef typename Base::value_compare          value_compare; 
  typedef value_type&amp;                           reference;
  typedef const value_type&amp;                     const_reference;
  typedef boost::uint64_t                       size_type;
  typedef value_type*                           pointer;
  typedef const value_type*                     const_pointer;

  typedef iterator_type&lt;const value_type&gt;       iterator;
  typedef iterator                              const_iterator;

  typedef std::reverse_iterator&lt;iterator&gt;       reverse_iterator;
  typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
  typedef std::pair&lt;const_iterator, const_iterator&gt;
                                                const_iterator_range;

  typedef typename Traits::page_id_type         page_id_type;
  typedef typename Traits::page_size_type       page_size_type;
  typedef typename Traits::page_level_type      page_level_type;

  // construct/destroy:

  explicit btree_map(const Comp&amp; comp = Comp());

  explicit btree_map(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  template &lt;class InputIterator&gt;
  btree_map(InputIterator begin, InputIterator end,
    const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size,  // ignored if existing file
    const Comp&amp; comp = Comp());

  ~btree_base();

  //  file operations:
  void open(const boost::filesystem::path&amp; p,
    flags::bitmask flgs = flags::read_only,
    uint64_t signature = -1, 
    std::size_t pg_sz = default_page_size);
  void flush();
  void close();

  // TODO: operator unspecified-bool-type, operator!
  
  // iterators:

  const_iterator          begin() const;
  const_iterator          end() const;
  const_iterator          last() const;
  const_reverse_iterator  rbegin() const;     
  const_reverse_iterator  rend() const;

  const_iterator          cbegin() const;
  const_iterator          cend() const;
  const_reverse_iterator  crbegin() const;    
  const_reverse_iterator  crend() const;

  // observers:
  key_compare             key_comp() const;
  value_compare           value_comp() const;
  const buffer_manager&amp;   manager() const;
  bool                    is_open() const;
  const filesystem::path&amp; file_path() const;
  bool                    read_only() const;
  const header_page&amp;      header() const;
  void                    dump_dot(std::ostream&amp; os) const; // Graphviz dot format

  // capacity:
  bool                    empty() const;
  size_type               size() const;
  std::size_t             page_size() const;
  std::size_t             max_cache_size() const;
  void                    max_cache_size(std::size_t m);

  // modifiers:
  std::pair&lt;const_iterator, bool&gt;
                          emplace(const Key&amp; key, const T&amp; mapped_value);
  std::pair&lt;const_iterator, bool&gt;
                          insert(const map_value&lt;Key, T&gt;&amp; value);

  template &lt;class InputIterator&gt;
  void                    insert(InputIterator begin, InputIterator end);

  iterator                update(iterator itr, const T&amp; mapped_value);
  const_iterator          erase(const_iterator position);
  size_type               erase(const key_type&amp; k);
  const_iterator          erase(const_iterator first, const_iterator last);
  void                    clear();

  // operations:
  const_iterator          find(const key_type&amp; k) const;
  size_type               count(const key_type&amp; k) const;

  const_iterator          lower_bound(const key_type&amp; k) const;
  const_iterator          upper_bound(const key_type&amp; k) const;

  const_iterator_range    equal_range(const key_type&amp; k) const;
};
} // namespace btree
} // namespace boost</pre>

  <h3>btree_map constructors and open</h3>
  <pre>explicit btree_map(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());

template &lt;class InputIterator&gt;
btree_map(InputIterator begin, InputIterator end,
  const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size,  // ignored if existing file
  const Comp&amp; comp = Comp());</pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, signature, pg_sz, comp)</code>.</p>
    <p><i>Throws:</i> See <a href="#open">open</a>.</p>
  </blockquote>
  <pre>void <a name="open">open</a>(const boost::filesystem::path&amp; p,
  flags::bitmask flgs = flags::read_only,
  uint64_t signature = -1, 
  std::size_t pg_sz = default_page_size);</pre>
  <blockquote>
    <p><i>Throws:</i> <code>std::runtime_error</code> if the file exists and
    <code>flgs flags::truncate</code> is not set and:</p>
    <blockquote>
      <ul>
        <li>The file does not begin with a btree header, or</li>
        <li>Any of these attributes of the btree being opened are not equal to 
        the same attribute at time of file creation:<ul>
          <li><code>signature</code>,</li>
          <li>endianness,</li>
          <li>association arity [<i>Note:</i> sets are arity 1, maps are arity 2&nbsp;
          <i>-- end note</i>],</li>
          <li>association uniqueness [<i>Note:</i> sets and maps are unique, 
          multisets and multimaps are not unique&nbsp; <i>-- end note</i>],</li>
          <li><code>sizeof(key_type)</code>,</li>
          <li><code>sizeof(mapped_type)</code>.</li>
        </ul>
        </li>
      </ul>
    </blockquote>
  </blockquote>
  
  <hr>

  <p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->14 August 2013<!--webbot bot="Timestamp" endspan i-checksum="31357" --></p>

  <p>© Copyright Beman Dawes, 2013</p>

  <p>Distributed under the Boost Software License, Version 1.0. See
  <a href=
  "http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>

</html>