<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>B-Tree Reference</title>
  <link rel="stylesheet" type="text/css" href="minimal.css">
</head>

<body>
  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td width="277"><a href="../../../../index.htm"><img src=
      "../../../boost.png" alt="boost.png (6897 bytes)" align=
      "middle" width="300" height="86" border="0"></a></td>

      <td align="middle"><font size="7">B-Tree Library Reference</font></td>
    </tr>
  </table>

  <table border="0" cellpadding="5" cellspacing="0" style=
  "border-collapse: collapse" bordercolor="#111111" bgcolor=
  "#D7EEFF" width="100%">
    <tr>
      <td><a href="../../../index.htm">Boost Home</a>
      &nbsp;&nbsp; <a href="index.html">Library Home</a>
      &nbsp;&nbsp; <a href="reference.html">Reference</a>
      &nbsp;&nbsp; <a href="tutorial.html">Tutorial</a>
      &nbsp;&nbsp; <a href="faq.html">FAQ</a>
      &nbsp;&nbsp; <a href="portability_guide.htm">Portability</a></td>
    </tr>
  </table>

  <h2>B-tree associative containers</h2>

  <p>B-tree associative containers provide fast retrieval of external data based on keys. 
  The external data may be resident on hard disks, floppy disks, memory cards, 
  USB-sticks, or any other form of random-access external memory.</p>
  <ul>
    <li>The 
  library provides several kinds of  B-tree ordered associative containers: <code>btree_set</code>,
  <code>btree_multiset</code>, <code>btree_map</code> and <code>btree_multimap</code>. 
    These are collectively called <b><i>trees</i></b>, and are directly 
    analogous to <code>std::set</code>, <code>std::multiset</code>, <code>
    std::map</code>, and <code>std::multimap</code>.<br>
&nbsp;</li>
    <li>The library  provides several kinds of B-tree ordered associative containers 
    that act as indexes to random-access files: <code>btree_index_set</code>,
  <code>btree_index_multiset</code>, <code>btree_index_map</code>, and <code>btree_index_multimap</code>. These 
    are collectively called <b><i>indexes</i></b>. The standard library analogy 
    would be to use a standard library associative container of pointers to 
    index a vector holding the actual data.</li>
  </ul>
  
  
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
  <td align="center">
  <i><b>Class</b></i></td>
  <td align="center">
  <i><b>Header</b></i></td>
  </tr>
  <tr>
  <td><code>btree_set</code></td>
  <td><code>boost/btree/btree_set.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_multiset</code></td>
  <td><code>boost/btree/btree_set.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_index_set</code></td>
  <td><code>boost/btree/btree_index_set.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_index_multiset</code></td>
  <td><code>boost/btree/btree_index_set.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_map</code></td>
  <td><code>boost/btree/btree_map.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_multimap</code></td>
  <td><code>boost/btree/btree_map.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_index_map</code></td>
  <td align="center"><code>boost/btree/btree_index_map.hpp</code></td>
  </tr>
  <tr>
  <td><code>btree_index_multimap</code></td>
  <td align="center"><code>boost/btree/btree_index_map.hpp</code></td>
  </tr>
  </table>

  <p>Each associative container is parameterized on <code>Key</code> 
  and an ordering relation <code>Compare</code> that induces a strict weak 
  ordering on elements of <code>Key</code>. In addition, the associative 
  container classes with <code>map</code> in their name associate a mapped type <code>T</code> 
  with the <code>Key</code>, and are collectively called <i><b>maps</b></i>. The 
  associative container classes with <code>set</code> in their name do not associate a mapped type with the <code>Key</code>, 
  and are collectively called <i><b>sets</b></i>. The object of type <code>Compare</code> is called 
  the comparison object of a container. </p>
  <p>The phrase “equivalence of keys” means the equivalence relation imposed by 
  the comparison and <i>not</i> the <code>operator==</code> on keys. That is, 
  two keys <code>k1</code> and <code>k2</code> are considered to be equivalent 
  if for the comparison object <code>comp</code>, <code>comp(k1, k2) == false &amp;&amp; 
  comp(k2, k1) == false</code>. For any two keys<code> k1</code> and <code>k2</code> 
  in the same container, calling <code>comp(k1, k2)</code> shall always return 
  the same value. </p>
  <p>An associative container supports unique keys if it may contain at most one 
  element for each key. Otherwise, it supports equivalent keys. The associative 
  container classes without <code>multi</code> in their name support unique keys and are collectively 
  called <i><b>unique</b></i> containers. The associative container classes
  <code>multi</code> in their name support equivalent keys and are 
  collectively called <i><b>equivalent</b></i> containers. For equivalent 
  containers, <code>insert</code>, <code>emplace</code>, and 
  <code>erase</code> preserve the relative ordering of 
  equivalent elements. </p>
  <p>For sets the value type is the same as the key type. For maps the value 
  type is 
  <code>std::pair&lt;const Key, T&gt;</code>, except that for indexes either of 
  the two types in the pair may be references.</p>
  <h3><a name="Requirements-on-template-parameters">Requirements on template 
  parameters</a></h3>

  <p>Types supplied by the <code>Key</code> and <code>T</code> template 
  parameters are required to:</p>

  <ul>
    <li>Be fixed-length, determinable by <code>sizeof</code>.</li>
    <li dir="ltr">

  <p dir="ltr">Still be valid after copy via <code>std::memcpy</code> to a 
  different memory location.</p>

    </li>
    <li>

  <p dir="ltr">Not contain pointers or references, except in the case of 
  indexes, where pointers and references are allowed in ephemeral proxy classes 
  like <code>std::string_view</code>.</p>

    </li>
  </ul>

  <p>[<i>Note:</i> None of the standard library container or container-like 
  types meet these requirements. <i>--end note</i>]</p>

  <h3>Iterators</h3>

  <p>Iterators of associative containers are bidirectional iterators. For sets, 
  iterator types <code>iterator</code> and <code>const_iterator</code> are the 
  same type and it is a constant iterator. For maps, iterator types <code>
  iterator</code> and <code>const_iterator</code> are different types and <code>
  const_iterator</code> is a constant iterator.</p>

  <p>Functions <code>insert()</code>,&nbsp; <code>emplace()</code>, and <code>
  erase()</code> invalidate iterators.</p>

  <p>Interfaces traffic in <code>const_iterator</code>. Maps provide a <code>
  writable()</code> function that turns a <code>const_iterator</code> into an
  <code>iterator</code>.</p>

  <h2><a name="Common-interface">Interface</a> and functionality</h2>

  <p>All associative containers 
  share the same description. Material which is specific to particular container 
  types uses <i><b>bold italic font</b></i> to indicate the applicable type or 
  types.</p>

  <h3><a name="Common synopsis">Synopsis</a></h3>
  <pre>namespace boost { namespace btree
{
  template &lt;class Key,
            <i><b>class T,  // maps only</b></i>
            class Traits = default_traits,
            class Compare = btree::less&gt;
  class <b><i>class-name    // see below</i></b>
  {
  public:
    // types:
    typedef Key                     key_type;
    typedef T                       mapped_type;      <i><b>// maps</b></i>
    typedef Key                     value_type;       <i><b>// sets</b></i>
    typedef std::pair&lt;const Key, T&gt; value_type;<i><b>       // maps</b></i>
    typedef Traits                  traits_type;
    typedef Compare                 key_compare;
    typedef const value_type&amp;       reference;<i><b>        // sets</b></i>
    typedef value_type&amp;             reference;<i><b>        // maps</b></i>
    typedef const value_type&amp;       const_reference;
    typedef <i>implementation-defined</i>  iterator;
    typedef <i>implementation-defined</i>  const_iterator;
    typedef uint64_t                size_type;
    typedef int64_t                 difference_type;
    typedef const value_type*       pointer;          <i><b>// sets</b></i>
    typedef value_type*             pointer;          <i><b>// maps</b></i>
    typedef const value_type*       const_pointer;
    typedef std::reverse_iterator&lt;iterator&gt;
                                    reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt;
                                    const_reverse_iterator;

    typedef Compare                 value_compare;    <i><b>// sets</b></i>

    <i><b>// maps:</b></i>
    class value_compare
    {
      friend class <b><i>class-name</i></b>;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type&amp; x, const value_type&amp; y) const
      {
        return comp(x.first, y.first);
      }
    };
    
    // <a href="#btree_set-constructors-and-destructor">construction and destruction</a>
    explicit <b><i>class-name</i></b>();

    <b><i>// trees:</i></b>
        explicit <b><i>class-name</i></b>(const path_type&amp; pth,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1,
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size); 

        template &lt;class InputIterator&gt;
      <b><i>  class-name</i></b>(InputIterator begin, InputIterator end,
          const path_type&amp; pth,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1,
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size);

    <b><i>// indexes:</i></b> 
        <b><i>class-name</i></b>(const path_type&amp; index_pth,
          const path_type&amp; file_pth,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1,
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size); 

        <b><i>class-name</i></b>(const path_type&amp; index_pth,
          file_ptr_type file_ptr,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1,
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size); 

   ~<b><i>class-name</i></b>();

    // <a href="#btree_set-file-operations">file operations</a>

    <i><b>// trees:</b></i>
        void open(const path_type&amp; pth,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1, 
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size);
 
    <i><b>// indexes:</b></i>
        void open(const path_type&amp; index_pth,
          const path_type&amp; file_pth,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1, 
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size);
 
        void open(const path_type&amp; pth,
          file_ptr_type file_ptr,
          flags::bitmask flgs = flags::read_only, uint64_t sig = -1, 
          const Compare&amp; comp = Compare(), std::size_t node_sz = default_node_size);
 
    void                    flush();
    void                    close();

    // <a href="#btree_set-iterators">iterators</a>
    const_iterator          begin() const;
    const_iterator          end() const;
    const_reverse_iterator  rbegin() const;     
    const_reverse_iterator  rend() const;
    const_iterator          cbegin() const;
    const_iterator          cend() const;
    const_reverse_iterator  crbegin() const;     
    const_reverse_iterator  crend() const;

    // <a href="#btree_set-observers">observers</a>
    bool                    is_open() const;
    const filesystem::path&amp; path() const;
    flags::bitmask          flags() const;

    const buffer_manager&amp;   manager() const;
    const header_page&amp;      header() const;

    key_compare             key_comp() const;
    value_compare           value_comp() const;
    bool                    ok_to_pack() const;

    // <a href="#btree_set-capacity">capacity</a>
    bool                    empty() const;
    size_type               size() const;
    size_type               max_size() const;
    std::size_t             node_size() const;
    std::size_t             max_cache_size() const;
                           
    // <a href="#btree_set-tuning">tuning</a>             
    void                    max_cache_size(std::size_t m);  // -1 indicates unlimited
    void                    max_cache_megabytes(std::size_t mb);

    // <b><i>indexes only

    </i></b>file_ptr_type           file() const;
    const filesystem::path&amp; file_path() const;
    file_size_type          file_size() const;
    file_size_type          file_reserve() const;
    file_position           position(const_iterator itr) const;

    // <a href="#btree_set-modifiers">modifiers</a>    

    std::pair&lt;const_iterator, bool&gt;
                   emplace(const value_type&amp; x);  <i><b>// unique sets only</b></i>
    const_iterator emplace(const value_type&amp; x);  <i><b>// equivalent sets only</b></i>
    std::pair&lt;const_iterator, bool&gt;
                   emplace(const key_type&amp; k, const mapped_type&amp; x); <i><b>// unique maps only</b></i>
    const_iterator emplace(const key_type&amp; k, const mapped_type&amp; x); <i><b>// equivalent sets only</b></i>

    std::pair&lt;const_iterator, bool&gt;
                   insert(const value_type&amp; x);  <i><b>// unique containers only</b></i>
    const_iterator insert(const value_type&amp; x);  <i><b>// equivalent containers only</b></i>

    template &lt;class InputIterator&gt;
      void                  insert(InputIterator begin, InputIterator end);

    const_iterator          erase(const_iterator position);
    size_type               erase(const key_type&amp; k);
    const_iterator          erase(const_iterator first, const_iterator last);
    void                    clear();

    // <a href="#btree_set-operations">operations</a>
    template &lt;class K&gt;
      const_iterator        find(const K&amp; k) const;
    const_iterator          find(const key_type&amp; k) const;

    template &lt;class K&gt;
      size_type             count(const K&amp; k) const;
    size_type               count(const key_type&amp; k) const;

    template &lt;class K&gt;
      const_iterator        lower_bound(const K&amp; k) const;
    const_iterator          lower_bound(const key_type&amp; k) const;

    template &lt;class K&gt;
      const_iterator        upper_bound(const K&amp; k) const;
    const_iterator          upper_bound(const key_type&amp; k) const;

    template &lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt;  equal_range(const K&amp; k) const;
    std::pair&lt;const_iterator, const_iterator&gt;    equal_range(const key_type&amp; k) const;
  };

  // non-member functions

  <i><b>// Template parameter T is only present for maps</b></i>
    
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator==(const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator&lt; (const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator!=(const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator&gt; (const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator&gt;=(const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);
  template &lt;class Key, class T, class Traits, class Compare&gt;
    bool operator&lt;=(const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; x,
      const <b><i>class-name</i></b>&lt;Key,T,Traits,Compare&gt;&amp; y);

}}  // namespaces</pre>

<h4><a name="btree_set-constructors-and-destructor">Construction and destruction</a> </h4>

  <pre>explicit <b><i>class-name</i></b>();</pre>
  <blockquote>
    <p><i>Postconditions:</i> <code>is_open()</code> is <code>false</code>.</p>
  </blockquote>
  <pre>explicit <b><i>class-name</i></b>(const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, sig, comp, node_sz)</code></p>
  </blockquote>
  <pre>template &lt;class InputIterator&gt;
<b><i>class-name</i></b>(InputIterator begin, InputIterator end,
  const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Effects:</i> <code>open(p, flgs, sig, comp, node_sz)</code></p>
  </blockquote>
  <pre>~<b><i>class-name</i></b>();</pre>
  <blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <pre>try { close(); }
catch (...) {}</pre>
  </blockquote>
  </blockquote>
  
  <h4><a name="btree_set-file-operations">File operations</a></h4>
  
  <pre>void open(const boost::filesystem::path&amp; pth,
  flags::bitmask flgs = flags::read_only,
  uint64_t sig = -1,  
  const Compare&amp; comp = Compare(),
  std::size_t node_sz = default_node_size); </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>false</code>.<p><i>Postconditions:</i><blockquote>
      <blockquote>
        <blockquote>
    
    <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="550">
      <tr>
        <td align="center" width="50%"><i><b>File <code>p</code> does not exist<br>
        or flgs &amp; flags::truncate</b></i></td>
        <td align="center" width="50%"><i><b>File <code>p</code> exists</b></i></td>
      </tr>
      <tr>
        <td width="50%"><code>path() == p</code></td>
        <td width="50%"><code>path() == p</code></td>
      </tr>
      <tr>
        <td width="50%"><code>is_open() == true</code></td>
        <td width="50%">
        <p><code>is_open() == true</code></td>
      </tr>
      <tr>
        <td width="50%"><code>key_comp() == comp</code></td>
        <td width="50%">
        <p><code>key_comp() == comp</code></td>
      </tr>
      <tr>
        <td width="50%"><code>value_comp() == comp</code></td>
        <td width="50%">
        <p><code>value_comp() == comp</code></td>
      </tr>
      <tr>
        <td width="50%"><code>node_size() == node_sz</code></td>
        <td width="50%">
        <p><code>node_size() == node_sz</code></td>
      </tr>
      <tr>
        <td width="50%"><code>empty() == true</code></td>
        <td width="50%">&nbsp;</td>
      </tr>
      <tr>
        <td width="50%"><code>size() == 0</code></td>
        <td width="50%">&nbsp;</td>
      </tr>
    </table>
        </blockquote>
      </blockquote>
    </blockquote>
    
    <p><i>Throws:</i> If the path <code>p</code> cannot be opened, or the type 
    or signature differ from when the file was originally created.</p>
  </blockquote>
  <pre>void  flush();</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Any data that has been modified is written to the 
    external file.</p>
  </blockquote>
  <pre>void  close();</pre>
  <blockquote>
    <p><i>Effects:</i> if <code>is_open()</code>, <code>flush()</code> and then 
    close the external file. Otherwise, no effect.</p>
    <p><i>Postconditions:</i> <code>is_open() == false</code></p>
  </blockquote>
  <h4><a name="btree_set-iterators">Iterators</a></h4>
  <pre>const_iterator  begin() const;
const_iterator  cbegin() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element in the 
    container.</p>
  </blockquote>
  <pre>const_iterator  end() const;
const_iterator  cend() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A past-the-end iterator that does not point to an element 
    in the container.</p>
  </blockquote>
  <pre>const_reverse_iterator  rbegin() const;
const_reverse_iterator  crbegin() const;  </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> <code>std::reverse_iterator(end())</code>.</p>
  </blockquote>
  <pre>const_reverse_iterator  rend() const;
const_reverse_iterator  crend() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> <code>std::reverse_iterator(begin())</code>.</p>
  </blockquote>
    <h4><a name="btree_set-observers">Observers</a></h4>
  <pre>bool  is_open() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>true</code> if the <code>open</code> function has 
    been called and did not throw and exception, and the <code>close</code> 
    function has not been subsequently called. Otherwise, <code>false</code>.</p>
  </blockquote>
  <pre>const filesystem::path&amp; path() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A copy of <code>pth</code> from the constructor or <code>
    open</code> function that opened the file.</p>
  </blockquote>
  <pre>flags::bitmask  flags() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The effective value of <code>flgs</code> from 
    the constructor or <code>open</code> function that opened the file.</p>
    <p><i>Remarks:</i> The effective value is the actual value 
    adjusted to reflect possible presence of <code>unique</code> and <code>
    key_only</code> flags, and application of hints.</p>
  </blockquote>
  <pre>const buffer_manager&amp;  manager() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A reference to the <code>buffer_manager</code> object for 
    the container.</p>
  </blockquote>
  <pre>const header_page&amp;  header() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A reference to the <code>header_page</code> object for 
    the container.</p>
  </blockquote>
  <pre>key_compare  key_comp() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The comparison object from the constructor or <code>open</code> 
    function.</p>
  </blockquote>
  <pre>value_compare  value_comp() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> A <code>value_compare</code> object constructed from the 
    comparison object from the constructor or <code>open</code> function.</p>
  </blockquote>
  <pre>bool  ok_to_pack() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>true</code> if all prior <code>insert</code> and
    <code>emplace</code> calls have been applied at <code>end()</code>, and 
    there have been no <code>erase</code> calls.</p>
  </blockquote>
    <h4><a name="btree_set-capacity">Capacity</a></h4>
  <pre>bool  empty() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>!size()</code></p>
  </blockquote>
  <pre>size_type  size() const;</pre>
  <blockquote>
    <p><i>Returns:</i> The number of elements in the container.</p>
  </blockquote>
  <pre>size_type  max_size() const;</pre>
  <blockquote>
    <p><i>Returns:</i> <code>-1</code>.</p>
    <p>[<i>Note:</i> This function is effectively useless, and is 
    provided only because the standard library provides a similar useless 
    function! <i>-- end note</i>]</p>
  </blockquote>
  <pre>std::size_t  node_size() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The value of the <code>node_sz</code> argument to the
    <code>open</code> function at the time of original file creation.</p>
  </blockquote>
  <pre>std::size_t  max_cache_size() const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The value of the <code>max</code> argument to the most 
    recent call to the <code>max_cache_size</code> function.</p>
  </blockquote>
    <h4><a name="btree_set-tuning">Tuning</a></h4>
  <pre>void  max_cache_size(std::size_t max);  </pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i>&nbsp; Informs the implementation of the maximum number of 
    nodes to be cached. <code>max</code> of <code>-1</code> indicates no limit.</p>
    <p>[<i>Note:</i> More nodes may be cached if required to maintain the 
    validity of outstanding iterators. <i>-- end note</i>]</p>
  </blockquote>
  <pre>void  max_cache_megabytes(std::size_t mb);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> <code>max_cache_size((mb*1048576)/node_size())</code><i>.</i></p>
  </blockquote>
    <h4><a name="btree_set-modifiers">Modifiers</a></h4>
  <pre>std::pair&lt;const_iterator, bool&gt; emplace(const value_type&amp; x);<b><i>  // btree_set only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts <code>x</code> if and only if there is no element in the 
    container with key equivalent to <code>x</code>. The bool component of the 
    returned pair is true if and only if the insertion takes place, and the 
    iterator component of the pair points to the element with key equivalent to 
    the key of <code>x</code>.</p>
    <p><i>Returns:</i> The pair described in <i>Effects</i>.</p>
  </blockquote>
  <pre>const_iterator emplace(const value_type&amp; x);  <b><i>// btree_multiset only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts <code>x</code>. If a range containing elements 
    equivalent to <code>x</code> exists, <code>x</code> is inserted at the end 
    of that range.</p>
    <p><i>Returns:</i> An iterator pointing to the newly inserted element.</p>
  </blockquote>
  <pre>std::pair&lt;const_iterator, bool&gt;
  emplace(const key_type&amp; k, const mapped_type&amp; m);<b><i>  // btree_map only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts an element constructed from <code>k</code> and
    <code>m</code> if and only if there is no element in the 
    container with key equivalent to <code>k</code>. The bool component of the 
    returned pair is true if and only if the insertion takes place, and the 
    iterator component of the pair points to the element with key equivalent to
    <code>k</code>.</p>
    <p><i>Returns:</i> The pair described in <i>Effects</i>.</p>
  </blockquote>
  <pre>std::pair&lt;const_iterator, bool&gt;
  emplace(const key_type&amp; k, const mapped_type&amp; m);<b><i>  // btree_multimap only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts an element constructed from <code>k</code> and
    <code>m</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the newly inserted element.</p>
  </blockquote>
  <pre>std::pair&lt;const_iterator, bool&gt; insert(const value_type&amp; x);  <b><i>// btree_set and btree_map only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts <code>x</code> if and only if there is no 
    element in the container with key equivalent to the key of <code>x</code>. 
    The <code>bool</code> component of the returned pair is <code>true</code> if 
    and only if the insertion takes place, and the iterator component of the 
    pair points to the element with key equivalent to the key of <code>value</code>.</p>
    <p><i>Returns:</i> The pair described in <i>Effects</i>.</p>
  </blockquote>
  <pre>const_iterator insert(const value_type&amp; x);  <b><i>// btree_multiset and btree_multimap only</i></b></pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Inserts <code>x</code>. If a range containing 
    elements equivalent to <code>x</code> exists, <code>x</code> is 
    inserted at the end of that range.</p>
    <p><i>Returns:</i> An iterator pointing to the newly inserted element.</p>
  </blockquote>
  <pre>template &lt;class InputIterator&gt;
  void insert(InputIterator begin, InputIterator end);</pre>
  <blockquote>
    <p><i>Requires:</i></p>
    <ul>
      <li> <code>is_open()</code> is <code>true</code>. </li>
      <li> <code>value_type</code> is constructible from <code>
    *begin</code>.</li>
      <li> <code>begin</code> and <code>end</code> are not iterators 
    into <code>*this</code>. </li>
    </ul>
    <p><i>Effects:</i></p>
    <ul>
      <li><b><i>btree_set and btree_map:</i></b> Inserts each element from the range <code>[begin,end)</code> 
    if and only if there is no element with key equivalent to the key of that 
    element.</li>
      <li><b><i>btree_multiset and btree_multimap:</i></b> Inserts each element from the range <code>[begin,end)</code>.</li>
    </ul>
  </blockquote>
  <pre>const_iterator  erase(const_iterator position);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> Erases the element pointed to by <code>position</code>. 
    Returns an iterator pointing to the element immediately following <code>
    position</code> prior to the element being erased. If no such element 
    exists, returns <code>end()</code>.</p>
  </blockquote>
  <pre>size_type  erase(const key_type&amp; k);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> If it exists, erases the element in the container with 
    key equivalent to <code>k</code>.</p>
    <p><i>Returns:</i>&nbsp; The number of elements erased.</p>
  </blockquote>
  <pre>const_iterator  erase(const_iterator begin, const_iterator end);</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Effects:</i> Erases all the elements in the range <code>[begin,end)</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the element following the last 
    element erased, or <code>end()</code> if there is no element following the 
    last erased element. [<i>Note:</i> this iterator is equivalent to end, but 
    is a valid iterator whereas end has been invalidated by the erase. <i>--end 
    note</i>]</p>
  </blockquote>
  <pre>void  clear();</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Postconditions:</i> <code>empty()</code> is <code>true</code>.</p>
  </blockquote>
    <h4><a name="btree_set-operations">Operations</a></h4>
    <p>Objects of types <code>K</code> and <code>Key</code> are required to be
    <code>key_comp()</code> comparable.<br>
&nbsp;</p>
  <pre>template &lt;class K&gt;
const_iterator  find(const K&amp; k) const;
const_iterator  find(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element with the key 
    equivalent to <code>k</code>, or <code>end()</code> if no such element is 
    found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
size_type  count(const K&amp; k) const;
size_type  count(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> The number of elements with key equivalent to <code>k</code>.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator  lower_bound(const K&amp; k) const;
const_iterator  lower_bound(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element with key not 
    less than <code>k</code>, or <code>end()</code> if such an element is not 
    found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator  upper_bound(const K&amp; k) const;
const_iterator  upper_bound(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> An iterator pointing to the first element with key 
    greater than <code>k</code>, or <code>end()</code> if such an element is not 
    found.</p>
  </blockquote>
  <pre>template &lt;class K&gt;
const_iterator_range  equal_range(const K&amp; k) const;
const_iterator_range  equal_range(const Key&amp; k) const;</pre>
  <blockquote>
    <p><i>Requires:</i> <code>is_open()</code> is <code>true</code>.</p>
    <p><i>Returns:</i> Equivalent to <code>std::make_pair(lower_bound(k), 
    upper_bound(k)</code>).</p>
  </blockquote>

  <h2>Helpers</h2>

  <h3>Header &lt;boost/btree/helpers.hpp&gt;Synopsis</h3>

  <p>The components in this header are included by the other boost/btree 
  headers. </p>

  <div>

  <pre>namespace boost { namespace btree
{
  //  Version numbers and default constants
  static const uint16_t major_version = 0;  // version identification
  static const uint16_t minor_version = 1;

  static const std::size_t default_node_size = 4096;  // determined by O/S page size

  //  <a href="#Traits">Traits</a>
  struct big_endian_traits;
  struct little_endian_traits;
  struct native_endian_traits;
  
  typedef big_endian_traits  default_traits;  // see rationale below
  
  //  <a href="#Flags">Flags</a>
  namespace flags
  {
    enum bitmask;

    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m);
    bitmask permanent_flags(bitmask m);
  }  // namespace flags
  
  //  <a href="#Constants">Constants</a>
  const uint32_t KB = 1024;
  const uint32_t MB = 1048576;  // 1024 * 1024
  const uint32_t GB = 1073741824;  // 1024 * 1024 * 1024
  
  //  <a href="#Hint-based-defaults">Hint based defaults</a>
  std::size_t     max_cache_default(flags::bitmask flgs, std::size_t file_size);
  flags::bitmask  cache_branches_default(flags::bitmask flgs);
  std::size_t     reserve_default(flags::bitmask flgs);
  
  //  <a href="#Function-object-less">Function object btree::less</a>
  struct less
  {
    template &lt;class T, class U&gt bool operator()(const T& t, const U& u) const
      { return t  &lt; u; }
  };
  
}}  // namespaces</pre>
  </div>
  <h3><a name="Traits">Traits</a></h3>
  <p>Traits provide the types for management objects on B-tree disk nodes. Nodes 
  are usually 4096 bytes in length for current hard disk hardware, and every 
  byte wasted in overhead causes a measurable reduction in speed as the tree 
  adds levels. That may favor unaligned traits, particularly if the user&#39;s key 
  and mapped types are also unaligned.</p>
  <p>On the other hand, aligned types are in theory more efficient and generate 
  less code.</p>
  <p>Actual timing tests on typical 2012 desktop hardware and operating systems, 
  show virtually no real-world speed differences between aligned and unaligned 
  traits, or native and non-native endian traits. Other factors, such as maximum 
  cache size, size of mapped data, portability, and so on, determine B-tree 
  performance.</p>
  <p>The <code>big_endian_traits</code> are chosen as the default because file 
  dumps are easier to read, files are portable, and none of the other traits 
  show any measurable effect on performance.</p>

  <div>

  <pre>namespace boost { namespace btree
{
 struct big_endian_traits
  {
    typedef endian::big_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                 node_level_type;  // level of node; 0 for leaf node.
    typedef endian::big_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::big;
  };
  
  struct little_endian_traits
  {
    typedef endian::little_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::little_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
      = endian::order::little;
  };
    
  struct native_endian_traits
  {
    typedef endian::native_uint32un_t  node_id_type;     // node ids are page numbers
    typedef uint8_t                    node_level_type;  // level of node; 0 for leaf node.
    typedef endian::native_uint24un_t  node_size_type;   // permits large node sizes
    static const BOOST_SCOPED_ENUM(endian::order) header_endianness
  #   ifdef BOOST_BIG_ENDIAN
      = endian::order::big;
  #   else
      = endian::order::little;
  #   endif
  };

  typedef big_endian_traits  default_traits;  // see rationale above

}}  // namespaces </pre>


  <h3><a name="Flags">Flags</a></h3>

  <p>The <code>flags::bitmask</code> enum is a bitmask type [C++ 17.5.2.1.3 bitmask.types] 
  used to package disparate arguments to constructors and open functions into a 
  single value. </p>

  <pre>namespace boost { namespace btree
{
  namespace flags
  {
    enum bitmask
    {
      none          = 0,
  
      // bitmasks set by the implementation, ignored if passed in by user:
      unique        = 1,    // set or map
      key_only      = 2,    // set or multiset
   
      // open values (choose one):
      read_only   = 0x100,   // file must exist; opened in read-only mode.
      read_write  = 0x200,   // open existing file in read-write mode;
                             //   otherwise create new file.
      truncate    = 0x400,   // same as read_write except existing file truncated;
                             //   causes read_write to be set.
  
      // bitmask options set by user; not present in header:
      preload        = 0x1000, // existing file read to preload O/S file cache
      cache_branches = 0x2000, // enable permanent cache of all branch nodes touched;
                               // otherwise make branch node available when use count
                               // becomes 0, just like leaf nodes.
  
      // optimization hints; choose one. not present in header
      least_memory  = 0x10000,
      low_memory    = 0x20000,
      balanced      = 0,
      fast          = 0x30000,
      fastest       = 0x40000,
    };
  
    BOOST_BITMASK(bitmask);
  
    bitmask user_flags(bitmask m)         {return m & ~(unique|key_only);}
    bitmask permanent_flags(bitmask m)    {return m & (unique|key_only);}
  }  // namespace flags  
}}  // namespaces</pre>

  </div>

  <h3><a name="Constants">Constants</a></h3>

  <p>These constants are handy multipliers for specifying the large values 
  sometimes needed for size related function arguments. </p>

  <h3><a name="Hint-based-defaults">Hint based defaults</a></h3>

  <p>Internally, the optimization hint flags are translated into default values 
  by these functions. These values are unspecified to allow implementations to 
  make refinements as experience develops and hardware evolves. The functions 
  are exposed so that users can monitor the defaults if desired.</p>

  <h3><a name="Function-object-less">Function object <code>btree::less</code></a></h3>

  <p>Provides heterogeneous comparisons as required to implement indexes and 
  other indirect references. Also generally useful; see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">N3657</a>,
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">N3421</a>. 
  Heterogeneous comparisons will be provided in the C++14 standard library, but 
  until then <code>btree::less</code> provides the functionality.</p>
  <p>Note: Allowing <code>less::operator()</code> to accept arguments of two 
  different types does not eliminate the requirement that objects of the two 
  types be themselves <code>&lt;</code> comparable. For example, type <code>fat</code> 
  in <a href="../test/btree_unit_test.cpp">test/btree_unit_test.cpp</a> 
  supplies two non-member <code>operator&lt;</code> functions so that 
  a <code>fat</code> object to be <code>&lt;</code> compared to an <code>int</code> 
  and an <code>int</code> can be compared to a <code>fat</code> object. </p>

  <hr>

  <p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->29 August 2013<!--webbot bot="Timestamp" endspan i-checksum="31368" --></p>

  <p>© Copyright Beman Dawes, 2013</p>

  <p>Distributed under the Boost Software License, Version 1.0. See
  <a href=
  "http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>

</html>